import{_ as t,o as e,c,V as d}from"./chunks/framework.ced88878.js";const _=JSON.parse('{"title":"配置 Watch","description":"","frontmatter":{},"headers":[],"relativePath":"zh/tsconfig-reference/project-config/Configuring Watch.md","lastUpdated":1682668835000}'),o={name:"zh/tsconfig-reference/project-config/Configuring Watch.md"},a=d('<h1 id="配置-watch" tabindex="-1">配置 Watch <a class="header-anchor" href="#配置-watch" aria-label="Permalink to &quot;配置 Watch&quot;">​</a></h1><p>编译器支持使用环境变量配置如何监视文件和目录的变化。</p><h2 id="使用tsc-watchfile环境变量来配置文件监视" tabindex="-1">使用<code>TSC_WATCHFILE</code>环境变量来配置文件监视 <a class="header-anchor" href="#使用tsc-watchfile环境变量来配置文件监视" aria-label="Permalink to &quot;使用`TSC_WATCHFILE`环境变量来配置文件监视&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>PriorityPollingInterval</code></td><td style="text-align:left;">使用<code>fs.watchFile</code>但针对源码文件，配置文件和消失的文件使用不同的轮询间隔</td></tr><tr><td style="text-align:left;"><code>DynamicPriorityPolling</code></td><td style="text-align:left;">使用动态队列，对经常被修改的文件使用较短的轮询间隔，对未修改的文件使用较长的轮询间隔</td></tr><tr><td style="text-align:left;"><code>UseFsEvents</code></td><td style="text-align:left;">使用 <code>fs.watch</code>，它使用文件系统事件（但在不同的系统上可能不一定准确）来查询文件的修改/创建/删除。注意少数的系统如Linux，对监视者的数量有限制，如果使用<code>fs.watch</code>创建监视失败那么将通过<code>fs.watchFile</code>来创建监视</td></tr><tr><td style="text-align:left;"><code>UseFsEventsWithFallbackDynamicPolling</code></td><td style="text-align:left;">此选项与<code>UseFsEvents</code>类似，只不过当使用<code>fs.watch</code>创建监视失败后，回退到使用动态轮询队列进行监视（如<code>DynamicPriorityPolling</code>介绍的那样）</td></tr><tr><td style="text-align:left;"><code>UseFsEventsOnParentDirectory</code></td><td style="text-align:left;">此选项通过<code>fs.watch</code>（使用系统文件事件）监视文件的父目录，因此CPU占用率低但也会降低精度</td></tr><tr><td style="text-align:left;">默认 （无指定值）</td><td style="text-align:left;">如果环境变量<code>TSC_NONPOLLING_WATCHER</code>设置为<code>true</code>，监视文件的父目录（如同<code>UseFsEventsOnParentDirectory</code>）。否则，使用<code>fs.watchFile</code>监视文件，超时时间为<code>250ms</code>。</td></tr></tbody></table><h2 id="使用tsc-watchdirectory环境变量来配置目录监视" tabindex="-1">使用<code>TSC_WATCHDIRECTORY</code>环境变量来配置目录监视 <a class="header-anchor" href="#使用tsc-watchdirectory环境变量来配置目录监视" aria-label="Permalink to &quot;使用`TSC_WATCHDIRECTORY`环境变量来配置目录监视&quot;">​</a></h2><p>在那些Nodejs原生就不支持递归监视目录的平台上，我们会根据<code>TSC_WATCHDIRECTORY</code>的不同选项递归地创建对子目录的监视。 注意在那些原生就支持递归监视目录的平台上（如Windows），这个环境变量会被忽略。</p><table><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>RecursiveDirectoryUsingFsWatchFile</code></td><td style="text-align:left;">使用<code>fs.watchFile</code>监视目录和子目录，它是一个轮询监视（消耗CPU周期）</td></tr><tr><td style="text-align:left;"><code>RecursiveDirectoryUsingDynamicPriorityPolling</code></td><td style="text-align:left;">使用动态轮询队列来获取目录与其子目录的改变</td></tr><tr><td style="text-align:left;">默认 （无指定值）</td><td style="text-align:left;">使用<code>fs.watch</code>来监视目录及其子目录</td></tr></tbody></table><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>在编译器中<code>--watch</code>的实现依赖于Nodejs提供的<code>fs.watch</code>和<code>fs.watchFile</code>，两者各有优缺点。</p><p><code>fs.watch</code>使用文件系统事件通知文件及目录的变化。 但是它依赖于操作系统，且事件通知并不完全可靠，在很多操作系统上的行为难以预料。 还可能会有创建监视个数的限制，如Linux系统，在包含大量文件的程序中监视器个数很快被耗尽。 但也正是因为它使用文件系统事件，不需要占用过多的CPU周期。 典型地，编译器使用<code>fs.watch</code>来监视目录（比如配置文件里声明的源码目录，无法进行模块解析的目录）。 这样就可以处理改动通知不准确的问题。 但递归地监视仅在Windows和OSX系统上支持。 这就意味着在其它系统上要使用替代方案。</p><p><code>fs.watchFile</code>使用轮询，因此涉及到CPU周期。 但是这是最可靠的获取文件/目录状态的机制。 典型地，编译器使用<code>fs.watchFile</code>监视源文件，配置文件和消失的文件（失去文件引用），这意味着对CPU的使用依赖于程序里文件的数量。</p>',11),l=[a];function i(s,r,n,h,f,g){return e(),c("div",null,l)}const x=t(o,[["render",i]]);export{_ as __pageData,x as default};
