import{_ as s,o as e,c as a,V as n}from"./chunks/framework.ced88878.js";const u=JSON.parse('{"title":"TypeScript 2.5","description":"","frontmatter":{},"headers":[],"relativePath":"zh/release-notes/TypeScript[2.5].md","lastUpdated":1682668835000}'),o={name:"zh/release-notes/TypeScript[2.5].md"},p=n(`<h1 id="typescript-2-5" tabindex="-1">TypeScript 2.5 <a class="header-anchor" href="#typescript-2-5" aria-label="Permalink to &quot;TypeScript 2.5&quot;">​</a></h1><h2 id="可选的catch语句变量" tabindex="-1">可选的<code>catch</code>语句变量 <a class="header-anchor" href="#可选的catch语句变量" aria-label="Permalink to &quot;可选的\`catch\`语句变量&quot;">​</a></h2><p>得益于<a href="https://github.com/tinganho" target="_blank" rel="noreferrer">@tinganho</a>所做的工作，TypeScript 2.5实现了一个新的ECMAScript特性，允许用户省略<code>catch</code>语句中的变量。 例如，当使用<code>JSON.parse</code>时，你可能需要将对应的函数调用放在<code>try</code> / <code>catch</code>中，但是最后可能并不会用到输入有误时会抛出的<code>SyntaxError</code>（语法错误）。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> input </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">...</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F286C4;">try</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#BF9EEE;">JSON</span><span style="color:#F6F6F4;">.</span><span style="color:#62E884;">parse</span><span style="color:#F6F6F4;">(input);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span>
<span class="line"><span style="color:#F286C4;">catch</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// ^ 注意我们的 \`catch\` 语句并没有声明一个变量</span></span>
<span class="line"><span style="color:#F6F6F4;">    console.</span><span style="color:#62E884;">log</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">传入的 JSON 不合法</span><span style="color:#F286C4;">\\n\\n</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> input)</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> input </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;...&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">JSON</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">parse</span><span style="color:#24292E;">(input);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ^ 注意我们的 \`catch\` 语句并没有声明一个变量</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;传入的 JSON 不合法</span><span style="color:#005CC5;">\\n\\n</span><span style="color:#032F62;">&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> input)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="checkjs-ts-check-模式中的类型断言-转换语法" tabindex="-1"><code>checkJs</code>/<code>@ts-check</code> 模式中的类型断言/转换语法 <a class="header-anchor" href="#checkjs-ts-check-模式中的类型断言-转换语法" aria-label="Permalink to &quot;\`checkJs\`/\`@ts-check\` 模式中的类型断言/转换语法&quot;">​</a></h2><p>TypeScript 2.5 引入了在<a href="https://github.com/Microsoft/TypeScript/issues/5158" target="_blank" rel="noreferrer">使用纯 JavaScript 的项目中断言表达式类型</a>的能力。对应的语法是<code>/** @type {...} */</code>标注注释后加上被圆括号括起来，类型需要被重新演算的表达式。举例:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">var</span><span style="color:#F6F6F4;"> x </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#7B7F8B;">/** </span><span style="color:#F286C4;">@type</span><span style="color:#7B7F8B;"> </span><span style="color:#97E1F1;font-style:italic;">{SomeType}</span><span style="color:#7B7F8B;"> */</span><span style="color:#F6F6F4;"> (AnyParenthesizedExpression);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">/** </span><span style="color:#D73A49;">@type</span><span style="color:#6A737D;"> </span><span style="color:#6F42C1;">{SomeType}</span><span style="color:#6A737D;"> */</span><span style="color:#24292E;"> (AnyParenthesizedExpression);</span></span></code></pre></div><h2 id="包去重和重定向" tabindex="-1">包去重和重定向 <a class="header-anchor" href="#包去重和重定向" aria-label="Permalink to &quot;包去重和重定向&quot;">​</a></h2><p>在 TypeScript 2.5 中使用<code>Node</code>模块解析策略进行导入时，编译器现在会检查文件是否来自 &quot;相同&quot; 的包。如果一个文件所在的包的<code>package.json</code>包含了与之前读取的包相同的<code>name</code>和<code>version</code>，那么TypeScript会将它重定向到最顶层的包。这可以解决两个包可能会包含相同的类声明，但因为包含<code>private</code>成员导致他们在结构上不兼容的问题.</p><p>这也带来一个额外的好处，可以通过避免从重复的包中加载<code>.d.ts</code>文件减少内存使用和编译器及语言服务的运行时计算.</p><h2 id="preservesymlinks-保留符号链接-编译器选项" tabindex="-1"><code>--preserveSymlinks</code>（保留符号链接）编译器选项 <a class="header-anchor" href="#preservesymlinks-保留符号链接-编译器选项" aria-label="Permalink to &quot;\`--preserveSymlinks\`（保留符号链接）编译器选项&quot;">​</a></h2><p>TypeScript 2.5带来了<code>preserveSymlinks</code>选项，它对应了<a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks" target="_blank" rel="noreferrer">Node.js 中 <code>--preserve-symlinks</code>选项</a>的行为。这一选项也会带来和Webpack的<code>resolve.symlinks</code>选项相反的行为（也就是说，将TypeScript的<code>preserveSymlinks</code>选项设置为<code>true</code>对应了将Webpack的<code>resolve.symlinks</code>选项设为<code>false</code>，反之亦然）。</p><p>在这一模式中，对于模块和包的引用（比如<code>import</code>语句和<code>/// &lt;reference type=&quot;..&quot; /&gt;</code>指令）都会以相对符号链接文件的位置被解析，而不是相对于符号链接解析到的路径。更具体的例子，可以参考<a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks" target="_blank" rel="noreferrer">Node.js网站的文档</a>。</p>`,13),l=[p];function c(t,r,i,y,d,h){return e(),a("div",null,l)}const E=s(o,[["render",c]]);export{u as __pageData,E as default};
