import{_ as s,o as n,c as a,V as l}from"./chunks/framework.ced88878.js";const u=JSON.parse('{"title":"TypeScript 4.8","description":"","frontmatter":{},"headers":[],"relativePath":"zh/release-notes/TypeScript[4.8].md","lastUpdated":1682668835000}'),o={name:"zh/release-notes/TypeScript[4.8].md"},p=l(`<h1 id="typescript-4-8" tabindex="-1">TypeScript 4.8 <a class="header-anchor" href="#typescript-4-8" aria-label="Permalink to &quot;TypeScript 4.8&quot;">​</a></h1><h2 id="改进的交叉类型化简、联合类型兼容性以及类型细化" tabindex="-1">改进的交叉类型化简、联合类型兼容性以及类型细化 <a class="header-anchor" href="#改进的交叉类型化简、联合类型兼容性以及类型细化" aria-label="Permalink to &quot;改进的交叉类型化简、联合类型兼容性以及类型细化&quot;">​</a></h2><p>TypeScript 4.8 为 <code>--strictNullChecks</code> 带来了一系列修正和改进。 这些变化会影响交叉类型和联合类型的工作方式，也作用于 TypeScript 的类型细化。</p><p>例如，<code>unknown</code> 与 <code>{} | null | undefined</code> 类型神似， 因为它接受 <code>null</code>，<code>undefined</code> 以及任何其它类型。 TypeScript 现在能够识别出这种情况，允许将 <code>unknown</code> 赋值给 <code>{} | null | undefined</code>。</p><blockquote><p>译者注：除 <code>null</code> 和 <code>undefined</code> 类型外，其它任何类型都可以赋值给 <code>{}</code> 类型。</p></blockquote><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">f</span><span style="color:#F6F6F4;">(</span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">unknown</span><span style="color:#F6F6F4;">, </span><span style="color:#FFB86C;font-style:italic;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> {} </span><span style="color:#F286C4;">|</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">|</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">undefined</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    x </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> y; </span><span style="color:#7B7F8B;">// 可以工作</span></span>
<span class="line"><span style="color:#F6F6F4;">    y </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> x; </span><span style="color:#7B7F8B;">// 以前会报错，现在可以工作</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(</span><span style="color:#E36209;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">unknown</span><span style="color:#24292E;">, </span><span style="color:#E36209;">y</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {} </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> y; </span><span style="color:#6A737D;">// 可以工作</span></span>
<span class="line"><span style="color:#24292E;">    y </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; </span><span style="color:#6A737D;">// 以前会报错，现在可以工作</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>另一个变化是 <code>{}</code> 与任何其它对象类型交叉会得到那个对象类型。 因此，我们可以重写 <code>NonNullable</code> 类型为与 <code>{}</code> 的交叉类型， 因为 <code>{} &amp; null</code> 和 <code>{} &amp; undefined</code> 会被消掉。</p><div class="language-diff"><button title="Copy Code" class="copy"></button><span class="lang">diff</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#EE6666;">- type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span></span>
<span class="line"><span style="color:#62E884;">+ type NonNullable&lt;T&gt; = T &amp; {};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#B31D28;">- type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span></span>
<span class="line"><span style="color:#22863A;">+ type NonNullable&lt;T&gt; = T &amp; {};</span></span></code></pre></div><p>之所以称其为一项改进，是因为交叉类型可以被化简和赋值了， 而有条件类型目前是不支持的。 因此，<code>NonNullable&lt;NonNullable&lt;T&gt;&gt;</code> 至少可以简化为 <code>NonNullable&lt;T&gt;</code>，在以前这是不行的。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">foo</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt;(</span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">NonNullable</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt;, </span><span style="color:#FFB86C;font-style:italic;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">NonNullable</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">NonNullable</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt;&gt;) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    x </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> y; </span><span style="color:#7B7F8B;">// 一直没问题</span></span>
<span class="line"><span style="color:#F6F6F4;">    y </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> x; </span><span style="color:#7B7F8B;">// 以前会报错，现在没问题</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;(</span><span style="color:#E36209;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NonNullable</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;, </span><span style="color:#E36209;">y</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NonNullable</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">NonNullable</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;&gt;) {</span></span>
<span class="line"><span style="color:#24292E;">    x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> y; </span><span style="color:#6A737D;">// 一直没问题</span></span>
<span class="line"><span style="color:#24292E;">    y </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; </span><span style="color:#6A737D;">// 以前会报错，现在没问题</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这些变化还为我们带来了更合理的控制流分析和类型细化。 比如，<code>unknown</code> 在条件为“真”的分支中被细化为 <code>{} | null | undefined</code>。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">narrowUnknownishUnion</span><span style="color:#F6F6F4;">(</span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> {} </span><span style="color:#F286C4;">|</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">|</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">undefined</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (x) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        x;  </span><span style="color:#7B7F8B;">// {}</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        x;  </span><span style="color:#7B7F8B;">// {} | null | undefined</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">narrowUnknown</span><span style="color:#F6F6F4;">(</span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">unknown</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (x) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        x;  </span><span style="color:#7B7F8B;">// 以前是 &#39;unknown&#39;，现在是 &#39;{}&#39;</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        x;  </span><span style="color:#7B7F8B;">// unknown</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">narrowUnknownishUnion</span><span style="color:#24292E;">(</span><span style="color:#E36209;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {} </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (x) {</span></span>
<span class="line"><span style="color:#24292E;">        x;  </span><span style="color:#6A737D;">// {}</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        x;  </span><span style="color:#6A737D;">// {} | null | undefined</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">narrowUnknown</span><span style="color:#24292E;">(</span><span style="color:#E36209;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">unknown</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (x) {</span></span>
<span class="line"><span style="color:#24292E;">        x;  </span><span style="color:#6A737D;">// 以前是 &#39;unknown&#39;，现在是 &#39;{}&#39;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        x;  </span><span style="color:#6A737D;">// unknown</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>泛型也会进行类似的细化。 当检查一个值不为 <code>null</code> 或 <code>undefined</code> 时， TypeScript 会将其与 <code>{}</code> 进行交叉 - 等同于使用 <code>NonNullable</code>。 把所有变化放在一起，我们就可以在不使用类型断言的情况下定义下列函数。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">throwIfNullable</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt;(</span><span style="color:#FFB86C;font-style:italic;">value</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">NonNullable</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt; {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (value </span><span style="color:#F286C4;">===</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">undefined</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> value </span><span style="color:#F286C4;">===</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">throw</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">Error</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">Nullable value!</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 以前会报错，因为 &#39;T&#39; 不能赋值给 &#39;NonNullable&lt;T&gt;&#39;。</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 现在会细化为 &#39;T &amp; {}&#39; 并且不报错，因为它等同于 &#39;NonNullable&lt;T&gt;&#39;。</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> value;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">throwIfNullable</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;(</span><span style="color:#E36209;">value</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NonNullable</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (value </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Nullable value!&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 以前会报错，因为 &#39;T&#39; 不能赋值给 &#39;NonNullable&lt;T&gt;&#39;。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 现在会细化为 &#39;T &amp; {}&#39; 并且不报错，因为它等同于 &#39;NonNullable&lt;T&gt;&#39;。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>value</code> 细化为了 <code>T &amp; {}</code>，此时它与 <code>NonNullable&lt;T&gt;</code> 等同 - 因此在函数体中不再需要使用 TypeScript 的特定语法。</p><p>就该改进本身而言可能是一个很小的变化 - 但它却实实在在地修复了在过去几年中报告的大量问题。</p><p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/49119" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="改进模版字符串类型中-infer-类型的类型推断" tabindex="-1">改进模版字符串类型中 <code>infer</code> 类型的类型推断 <a class="header-anchor" href="#改进模版字符串类型中-infer-类型的类型推断" aria-label="Permalink to &quot;改进模版字符串类型中 \`infer\` 类型的类型推断&quot;">​</a></h2><p>近期，TypeScript 支持了在有条件类型中的 <code>infer</code> 类型变量上添加 <code>extends</code> 约束。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">// 提取元组类型中的第一个元素，若其能够赋值给 &#39;number&#39;，</span></span>
<span class="line"><span style="color:#7B7F8B;">// 返回 &#39;never&#39; 若无这样的元素。</span></span>
<span class="line"><span style="color:#F286C4;">type</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">TryGetNumberIfFirst</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt; </span><span style="color:#F286C4;">=</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> [</span><span style="color:#F286C4;">infer</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">number</span><span style="color:#F6F6F4;">, </span><span style="color:#F286C4;">...</span><span style="color:#97E1F1;font-style:italic;">unknown</span><span style="color:#F6F6F4;">[]] </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">never</span><span style="color:#F6F6F4;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 提取元组类型中的第一个元素，若其能够赋值给 &#39;number&#39;，</span></span>
<span class="line"><span style="color:#6A737D;">// 返回 &#39;never&#39; 若无这样的元素。</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TryGetNumberIfFirst</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> [</span><span style="color:#D73A49;">infer</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">U</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#005CC5;">unknown</span><span style="color:#24292E;">[]] </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">U</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">never</span><span style="color:#24292E;">;</span></span></code></pre></div><p>若 <code>infer</code> 类型出现在模版字符串类型中且被原始类型所约束，则 TypeScript 会尝试将其解析为字面量类型。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">// SomeNum 以前是 &#39;number&#39;；现在是 &#39;100&#39;。</span></span>
<span class="line"><span style="color:#F286C4;">type</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">SomeNum</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">100</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#E7EE98;">\`</span><span style="color:#F286C4;">\${</span><span style="color:#F286C4;">infer</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#E7EE98;"> </span><span style="color:#F286C4;">extends</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">number</span><span style="color:#F286C4;">}</span><span style="color:#E7EE98;">\`</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">never</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// SomeBigInt 以前是 &#39;bigint&#39;；现在是 &#39;100n&#39;。</span></span>
<span class="line"><span style="color:#F286C4;">type</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">SomeBigInt</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">100</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#E7EE98;">\`</span><span style="color:#F286C4;">\${</span><span style="color:#F286C4;">infer</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#E7EE98;"> </span><span style="color:#F286C4;">extends</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">bigint</span><span style="color:#F286C4;">}</span><span style="color:#E7EE98;">\`</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">never</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// SomeBool 以前是 &#39;boolean&#39;；现在是 &#39;true&#39;。</span></span>
<span class="line"><span style="color:#F286C4;">type</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">SomeBool</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">true</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#E7EE98;">\`</span><span style="color:#F286C4;">\${</span><span style="color:#F286C4;">infer</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#E7EE98;"> </span><span style="color:#F286C4;">extends</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F286C4;">}</span><span style="color:#E7EE98;">\`</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">U</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">never</span><span style="color:#F6F6F4;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// SomeNum 以前是 &#39;number&#39;；现在是 &#39;100&#39;。</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SomeNum</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;100&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`\${</span><span style="color:#D73A49;">infer</span><span style="color:#032F62;"> </span><span style="color:#6F42C1;">U</span><span style="color:#032F62;"> </span><span style="color:#D73A49;">extends</span><span style="color:#032F62;"> </span><span style="color:#005CC5;">number</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">U</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">never</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// SomeBigInt 以前是 &#39;bigint&#39;；现在是 &#39;100n&#39;。</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SomeBigInt</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;100&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`\${</span><span style="color:#D73A49;">infer</span><span style="color:#032F62;"> </span><span style="color:#6F42C1;">U</span><span style="color:#032F62;"> </span><span style="color:#D73A49;">extends</span><span style="color:#032F62;"> </span><span style="color:#005CC5;">bigint</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">U</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">never</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// SomeBool 以前是 &#39;boolean&#39;；现在是 &#39;true&#39;。</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SomeBool</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;true&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`\${</span><span style="color:#D73A49;">infer</span><span style="color:#032F62;"> </span><span style="color:#6F42C1;">U</span><span style="color:#032F62;"> </span><span style="color:#D73A49;">extends</span><span style="color:#032F62;"> </span><span style="color:#005CC5;">boolean</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">U</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">never</span><span style="color:#24292E;">;</span></span></code></pre></div><p>现在它能更好地表达代码库在运行时的行为，提供更准确的类型。</p><p>要注意的一点是当 TypeScript 解析这些字面量类型时会使用贪心策略，尽可能多地提取原始类型； 然后再回头检查解析出的原始类型是否匹配字符串的内容。 也就是说，TypeScript 检查从字符串到原始类型再到字符串是否匹配。 如果发现字符串前后对不上了，那么回退到基本的原始类型。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">// JustNumber 为 \`number\` 因为 TypeScript 解析 出 \`&quot;1.0&quot;\`，但 \`String(Number(&quot;1.0&quot;))\` 为 \`&quot;1&quot;\` 不匹配。</span></span>
<span class="line"><span style="color:#F286C4;">type</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">JustNumber</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">1.0</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#E7EE98;">\`</span><span style="color:#F286C4;">\${</span><span style="color:#F286C4;">infer</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#E7EE98;"> </span><span style="color:#F286C4;">extends</span><span style="color:#E7EE98;"> </span><span style="color:#97E1F1;font-style:italic;">number</span><span style="color:#F286C4;">}</span><span style="color:#E7EE98;">\`</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">never</span><span style="color:#F6F6F4;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// JustNumber 为 \`number\` 因为 TypeScript 解析 出 \`&quot;1.0&quot;\`，但 \`String(Number(&quot;1.0&quot;))\` 为 \`&quot;1&quot;\` 不匹配。</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">JustNumber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;1.0&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`\${</span><span style="color:#D73A49;">infer</span><span style="color:#032F62;"> </span><span style="color:#6F42C1;">T</span><span style="color:#032F62;"> </span><span style="color:#D73A49;">extends</span><span style="color:#032F62;"> </span><span style="color:#005CC5;">number</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">never</span><span style="color:#24292E;">;</span></span></code></pre></div><p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/48094" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="build-watch-和-incremental-的性能优化" tabindex="-1"><code>--build</code>, <code>--watch</code>, 和 <code>--incremental</code> 的性能优化 <a class="header-anchor" href="#build-watch-和-incremental-的性能优化" aria-label="Permalink to &quot;\`--build\`, \`--watch\`, 和 \`--incremental\` 的性能优化&quot;">​</a></h2><p>TypeScript 4.8 优化了使用 <code>--watch</code> 和 <code>--incremental</code> 时的速度，以及使用 <code>--build</code> 构建工程引用时的速度。 例如，现在在 <code>--watch</code> 模式下 TypeScript 不会去更新未改动文件的时间戳， 这使得重新构建更快，避免与其它监视 TypeScript 输出文件的构建工具之间产生干扰。 此外，TypeScript 也能够重用 <code>--build</code>, <code>--watch</code> 和 <code>--incremental</code> 之间的信息。</p><p>这些优化有多大效果？在一个相当大的代码库上，对于简单常用的操作有 10%-25% 的改进，对于无改动操作的场景节省了 40% 的时间。 在 TypeScript 代码库中我们也看到了相似的结果。</p><p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/48784" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="比较对象和数组字面量时报错" tabindex="-1">比较对象和数组字面量时报错 <a class="header-anchor" href="#比较对象和数组字面量时报错" aria-label="Permalink to &quot;比较对象和数组字面量时报错&quot;">​</a></h2><p>在许多语言中，<code>==</code> 操作符在对象上比较的是“值”。 例如，在 Python 语言中想检查列表是否为空时可以使用 <code>==</code> 检查该值是否与空列表相等。</p><div class="language-py"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> people_at_home </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> []:</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;">print</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">that&#39;s where she lies, broken inside. &lt;/3</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> people_at_home </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> []:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;that&#39;s where she lies, broken inside. &lt;/3&quot;</span><span style="color:#24292E;">)</span></span></code></pre></div><p>在 JavaScript 里却不是这样，使用 <code>==</code> 和 <code>===</code> 比较对象和数组时比较的是引用。 我们确信这会让 JavaScript 程序员搬起石头砸自己脚，且最坏的情况是在生产环境中存在 bug。 因此，TypeScript 现在不允许如下的代码：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> peopleAtHome </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (peopleAtHome </span><span style="color:#F286C4;">===</span><span style="color:#F6F6F4;"> []) {</span></span>
<span class="line"><span style="color:#7B7F8B;">//  ~~~~~~~~~~~~~~~~~~~</span></span>
<span class="line"><span style="color:#7B7F8B;">// This condition will always return &#39;false&#39; since JavaScript compares objects by reference, not value.</span></span>
<span class="line"><span style="color:#F6F6F4;">    console.</span><span style="color:#62E884;">log</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">that&#39;s where she lies, broken inside. &lt;/3</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> peopleAtHome </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (peopleAtHome </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> []) {</span></span>
<span class="line"><span style="color:#6A737D;">//  ~~~~~~~~~~~~~~~~~~~</span></span>
<span class="line"><span style="color:#6A737D;">// This condition will always return &#39;false&#39; since JavaScript compares objects by reference, not value.</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;that&#39;s where she lies, broken inside. &lt;/3&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>非常感谢<a href="https://github.com/Jack-Works" target="_blank" rel="noreferrer">Jack Works</a>的贡献。 更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/45978" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="改进从绑定模式中进行类型推断" tabindex="-1">改进从绑定模式中进行类型推断 <a class="header-anchor" href="#改进从绑定模式中进行类型推断" aria-label="Permalink to &quot;改进从绑定模式中进行类型推断&quot;">​</a></h2><p>在某些情况下，TypeScript 会从绑定模式中获取类型来帮助类型推断。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">declare</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">chooseRandomly</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt;(</span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;">, </span><span style="color:#FFB86C;font-style:italic;">y</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> [a, b, c] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">chooseRandomly</span><span style="color:#F6F6F4;">([</span><span style="color:#BF9EEE;">42</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">true</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">hi!</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">], [</span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">false</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">bye!</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">]);</span></span>
<span class="line"><span style="color:#7B7F8B;">//   ^  ^  ^</span></span>
<span class="line"><span style="color:#7B7F8B;">//   |  |  |</span></span>
<span class="line"><span style="color:#7B7F8B;">//   |  |  string</span></span>
<span class="line"><span style="color:#7B7F8B;">//   |  |</span></span>
<span class="line"><span style="color:#7B7F8B;">//   |  boolean</span></span>
<span class="line"><span style="color:#7B7F8B;">//   |</span></span>
<span class="line"><span style="color:#7B7F8B;">//   number</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">declare</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">chooseRandomly</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;(</span><span style="color:#E36209;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">, </span><span style="color:#E36209;">y</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> [a, b, c] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">chooseRandomly</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">42</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;hi!&quot;</span><span style="color:#24292E;">], [</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;bye!&quot;</span><span style="color:#24292E;">]);</span></span>
<span class="line"><span style="color:#6A737D;">//   ^  ^  ^</span></span>
<span class="line"><span style="color:#6A737D;">//   |  |  |</span></span>
<span class="line"><span style="color:#6A737D;">//   |  |  string</span></span>
<span class="line"><span style="color:#6A737D;">//   |  |</span></span>
<span class="line"><span style="color:#6A737D;">//   |  boolean</span></span>
<span class="line"><span style="color:#6A737D;">//   |</span></span>
<span class="line"><span style="color:#6A737D;">//   number</span></span></code></pre></div><p>当 <code>chooseRandomly</code> 需要确定 <code>T</code> 的类型时，它主要检查 <code>[42, true, &quot;hi!&quot;]</code> 和 <code>[0, false, &quot;bye!&quot;]</code>; 但 TypeScript 还需要确定这两个类型是 <code>Array&lt;number | boolean | string&gt;</code> 还是 <code>[number, boolean, string]</code>。 为此，它会检查当前类型推断候选列表中是否存在元组类型。 当 TypeScript 看到了绑定模式 <code>[a, b, c]</code>，它创建了类型 <code>[any, any, any]</code>， 该类型会被加入到 <code>T</code> 的候选列表（作为推断 <code>[42, true, &quot;hi!&quot;]</code> 和 <code>[0, false, &quot;bye!&quot;]</code> 的参考）但优先级较低。</p><p>这对 <code>chooseRandomly</code> 函数来讲不错，但在有些情况下不合适。例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">declare</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">function</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">f</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#FFB86C;font-style:italic;">T</span><span style="color:#F6F6F4;">&gt;(</span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F286C4;">?:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;">)</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">T</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> [x, y, z] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">f</span><span style="color:#F6F6F4;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">declare</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;(</span><span style="color:#E36209;">x</span><span style="color:#D73A49;">?:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> [x, y, z] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">();</span></span></code></pre></div><p>绑定模式 <code>[x, y, z]</code> 提示 <code>f</code> 应该输出 <code>[any, any, any]</code> 元组； 但是 <code>f</code> 不应该根据绑定模式来改变类型参数的类型。 它不应该像变戏法一样根据被赋的值突然变成一个类数组的值， 因此绑定模式过多地影响到了生成的类型。 由于绑定模式中均为 <code>any</code> 类型，因此我们也就让 <code>x</code>，<code>y</code> 和 <code>z</code> 为 <code>any</code> 类型。</p><p>在 TypeScript 4.8 里，绑定模式不会成为类型参数的候选类型。 它们仅在参数需要更确切的类型时提供参考，例如 <code>chooseRandomly</code> 的情况。 如果你想回到之前的行为，可以提供明确的类型参数。</p><p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/49086" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="修复文件监视-尤其是在-git-checkout-之间" tabindex="-1">修复文件监视（尤其是在 <code>git checkout</code> 之间） <a class="header-anchor" href="#修复文件监视-尤其是在-git-checkout-之间" aria-label="Permalink to &quot;修复文件监视（尤其是在 \`git checkout\` 之间）&quot;">​</a></h2><p>长久以来 TypeScript 中存在一个 bug，它对在编辑器中使用 <code>--watch</code> 模式监视文件改动处理的不好。 它有时表现为错误提示不准确，需要重启 <code>tsc</code> 或 VS Code 才行。 这在 Unix 系统上常发生，例如用 vim 保存了一个文件或切换了 git 的分支。</p><p>这是因为错误地假设了 Node.js 在不同文件系统下处理文件重命名的方式。 Linux 和 macOS 使用 <a href="https://en.wikipedia.org/wiki/Inode" target="_blank" rel="noreferrer">inodes</a>， <a href="https://nodejs.org/api/fs.html#inodes" target="_blank" rel="noreferrer">Node.js 监视的是 inodes 的变化而非文件路径</a>。 因此，当 Node.js 返回了 <a href="https://nodejs.org/api/fs.html#class-fsfswatcher" target="_blank" rel="noreferrer">watcher 对象</a>， 根据平台和文件系统的不同，它即可能监视文件路径也可能是 inode。</p><p>为了高效，TypeScript 尝试重用 watcher 对象，如果它检测到文件路径仍存在于磁盘上。 这里就产生了问题，因为即使给定路径上的文件仍然存在，但它可能是全新创建的文件，inode 已经发生了变化。 TypeScript 重用了 watcher 对象而非重新创建一个 watcher 对象，因此可能监视了一个完全不相关的文件。 TypeScript 4.8 能够在 inode 系统上处理这些情况，新建 watcher 对象。</p><p>非常感谢 <a href="https://github.com/MarcCelani-at" target="_blank" rel="noreferrer">Marc Celani</a> 和他的团队的贡献。 更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/48997" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="查找所有引用性能优化" tabindex="-1">查找所有引用性能优化 <a class="header-anchor" href="#查找所有引用性能优化" aria-label="Permalink to &quot;查找所有引用性能优化&quot;">​</a></h2><p>在编辑器中执行“查找所有引用”时，TypeScript 现在能够更智能地聚合引用。 在 TypeScript 自己的代码库中去搜索一个广泛使用的标识符时能够减少 20% 时间。</p><p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/49581" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="从自动导入中排除指定文件" tabindex="-1">从自动导入中排除指定文件 <a class="header-anchor" href="#从自动导入中排除指定文件" aria-label="Permalink to &quot;从自动导入中排除指定文件&quot;">​</a></h2><p>TypeScript 4.8 增加了一个编辑器首选项从自动导入中排除指定文件。 在 Visual Studio Code 里，可以将文件名和 globs 添加到 Settings UI 的 “Auto Import File Exclude Patterns” 下，或者 <code>.vscode/settings.json</code> 文件中：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">{</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// Note that \`javascript.preferences.autoImportFileExcludePatterns\` can be specified for JavaScript too.</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E2F2;">&quot;</span><span style="color:#97E1F1;">typescript.preferences.autoImportFileExcludePatterns</span><span style="color:#97E2F2;">&quot;</span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> [</span></span>
<span class="line"><span style="color:#F6F6F4;">      </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">**/node_modules/@types/node</span><span style="color:#DEE492;">&quot;</span></span>
<span class="line"><span style="color:#F6F6F4;">    ]</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Note that \`javascript.preferences.autoImportFileExcludePatterns\` can be specified for JavaScript too.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">&quot;typescript.preferences.autoImportFileExcludePatterns&quot;</span><span style="color:#24292E;">: [</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#032F62;">&quot;**/node_modules/@types/node&quot;</span></span>
<span class="line"><span style="color:#24292E;">    ]</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果你想避免导入某些模块或代码库，它个功能就派上用场了。 有些模块可能有过多的导出以致于影响到了自动导入功能，让我们难以选择一条自动导入。</p><p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/49578" target="_blank" rel="noreferrer">这里</a>。</p>`,58),e=[p];function t(c,r,y,F,i,d){return n(),a("div",null,e)}const C=s(o,[["render",t]]);export{u as __pageData,C as default};
