import{_ as e,o,c as t,V as s}from"./chunks/framework.ced88878.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/handbooks/handbook-v2/Type Manipulation/Creating Types from Types.md","lastUpdated":1682668835000}'),a={name:"zh/handbooks/handbook-v2/Type Manipulation/Creating Types from Types.md"},p=s('<p>TypeScript 的类型系统非常强大，因为它允许 <em>根据其他类型</em> 来表达类型。</p><p>这个想法的最简单形式是泛型，我们实际上有各种各样的_type operators_可供使用。 也可以根据我们已有的_值_来表达类型。</p><p>通过组合各种类型的运算符，我们可以用简洁、可维护的方式表达复杂的操作和值。 在本节中，我们将介绍根据现有类型或值来表达新类型的方法。</p><ul><li><a href="/tsdoc-vitepress/docs/handbook/2/generics.html">Generics</a> - 采用参数的类型</li><li><a href="/tsdoc-vitepress/docs/handbook/2/keyof-types.html">Keyof 类型运算符</a> - 使用 <code>keyof</code> 运算符创建新类型</li><li><a href="/tsdoc-vitepress/docs/handbook/2/typeof-types.html">Typeof 类型运算符</a> - 使用 <code>typeof</code> 运算符创建新类型</li><li><a href="/tsdoc-vitepress/docs/handbook/2/indexed-access-types.html">索引访问类型</a> - 使用 <code>Type[&#39;a&#39;]</code> 语法访问类型的子集</li><li><a href="/tsdoc-vitepress/docs/handbook/2/conditional-types.html">条件类型</a> - 类似于类型系统中的 if 语句的类型</li><li><a href="/tsdoc-vitepress/docs/handbook/2/mapped-types.html">映射类型</a> - 通过映射现有类型中的每个属性来创建类型</li><li><a href="/tsdoc-vitepress/docs/handbook/2/template-literal-types.html">模板文字类型</a> - 通过模板文字字符串更改属性的映射类型</li></ul>',4),d=[p];function i(c,r,n,l,_,h){return o(),t("div",null,d)}const m=e(a,[["render",i]]);export{y as __pageData,m as default};
